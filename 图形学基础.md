# 图形学基础

## 光栅化渲染管线

### 应用程序阶段

该阶段主要是在软件层⾯上执⾏的⼀些⼯作，包括空间加速算法、视锥剔除、碰撞检测、动画物理模拟等。⼤体逻辑是：执⾏视锥剔除，查询出可能需要绘制的图元并⽣成渲染数据，设置渲染状态和绑定各种Shader参数，调⽤DrawCall，进⼊到GPU渲染管线。

#### 输入装配阶段（Input Assembler State）：

输入装配阶段是渲染管线的起点，主要负责从用户提供的顶点数据缓冲区中读取并组装几何图元。它的核心工作分为两部分：

1. **数据读取与解释**：它根据指定的顶点格式（Vertex Format）和内存布局（如顶点缓冲区和索引缓冲区），从原始数据流中提取出每个顶点的属性信息，例如位置坐标、颜色、法线向量、纹理坐标等。
2. **图元组装**：随后，它将提取出的顶点按照指定的图元拓扑结构（如三角形列表、线条带等）进行分组，组装成完整的几何图元（如三角形、线条），并传递给管线的下一阶段（顶点着色器）。

### 几何阶段

#### 顶点着色器（Vertex Shader）

顶点着色器用来处理输入的顶点数据，主要用来进行顶点坐标变换以及顶点着色。

##### 坐标变换

其坐标变换过程遵循一个完整的空间转换链，目标是将三维模型数据最终映射到二维屏幕。流程如下：

1. **局部空间 -> 世界空间**：通过 **模型矩阵 (Model Matrix)** 变换，将顶点从模型自身的局部坐标系转换到统一的全局世界坐标系中。
2. **世界空间 -> 观察空间**：通过 **观察矩阵 (View Matrix)** 变换，将顶点从世界坐标系转换到以摄像机为原点的观察坐标系中。
3. **观察空间 -> 裁剪空间**：通过 **投影矩阵 (Projection Matrix)** 变换，将顶点转换到齐次裁剪空间中。**至此，顶点着色器的主要坐标变换工作完成**，其输出的顶点位置即位于此裁剪空间。

##### 顶点着色

- 平面着色 (Flat Shading)：平面着色是使用一个顶点颜色来代表整个三角面的颜色， 默认是使用索引中第一个顶点的颜色。

- 高洛德着色 (Gouraud Shading)：高洛德着色就是在顶点着色器中计算顶点的光照信息，所以也叫作逐顶点着色（Phong模型在片段着色器中计算每个片段的光照信息，也叫逐片段着色）。该方法会在顶点着色器中计算三个顶点的光照信息，然后在光栅化阶段插值得到三角形内部各个片段的光照信息。

#### 曲面细分着色器（Tessellation Shader）

曲面细分是利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数 量，是渲染管线一个可选的阶段。它由外壳着色器(Hull Shader)、镶嵌器(Tessellator)和 域着色器(Domain Shader)构成。

#### 几何着色器（Geometry Shader）

#### 图元组装（Primitive Assembly）

输入装配阶段的“组装”是数据准备，在顶点处理之前。光栅化之前的“图元组装”是几何重构，在顶点处理之后。

##### 裁剪（Clipping）

只有当图元部分或全部位于视椎体内时，我们才会将它送到流水线的下个阶段，也就是光栅化阶段。而完全位于视椎体外部的图元会在应用程序阶段被裁剪掉。而对于部分位于视椎体的图元，我们需要对他们进行所谓的剪裁操作，这部分几乎完全由硬件控制。

> [为什么在NDC已经包含了视锥体剔除功能的情况下还需要视锥体裁剪？](https://www.zhihu.com/question/304277310/answer/562221670)
>
> 简单来说，两次裁剪的区别在于粒度不同。前者是在物体对象层面进行的，通常通过对物体的包围盒进行测试，剔除那些完全位于视锥体之外的物体。而NDC裁剪则是在三角形层面进行的，由于部分三角形可能超出屏幕范围，因此需要裁剪掉位于屏幕之外的像素部分。

##### 背面剔除（Back-Face Culling）

##### 屏幕映射（Screen Mapping）

**透视除法**

透视除法是将顶点从齐次裁剪空间转换到归一化设备坐标空间的关键步骤。其核心操作是将顶点坐标的四个分量 `(x, y, z, w)` 同时除以 `w` 分量，得到新的坐标 `(x/w, y/w, z/w, 1)`。

它的核心意义在于实现透视投影中的**近大远小**效果：在透视投影矩阵变换后，`w` 分量实际保留了观察空间中物体的深度信息（一般与 `-z_view` 相关）。因此，当距离摄像机较远时 `w` 较大，除以后坐标值被压缩，自然呈现出远处物体变小的视觉效果。

需要说明的是，透视除法在图形管线中由硬件自动执行，且无论透视投影还是正交投影都会进行。在正交投影中，由于投影矩阵不改变 `w` 的值（保持为1），因此除法并未真正改变坐标，这也解释了为什么正交投影不产生近大远小的透视变形。

由此我们也更深入理解了齐次坐标的意义：它通过 `w` 分量，不仅统一了仿射与投影变换的表示，更重要的是为投影变换正确编码并保留了深度信息，使透视除法得以在后续阶段重建出正确的空间关系。

**视口变换**

透视除法后得到的NDC坐标是一个与具体硬件设备无关的标准化空间，其目的是为了**实现屏幕映射的通用性**。NDC坐标随后通过**视口变换**转换为**窗口坐标**。

这里需要区分两个容易混淆的概念：

- 屏幕坐标通常指一个纯粹的**2D概念**，仅用于表示像素在屏幕平面上的 `(X, Y)` 位置。
- 窗口坐标则是一个2.5D概念，它不仅包含 `(X, Y)` 位置，还保留了经过变换后的深度值。这个深度值（通常称为 `gl_FragCoord.z`）是后续深度测试与深度缓冲所依据的关键数据。

因此，视口变换的输出（窗口坐标）才是光栅化与片段着色器实际使用的、带有完整空间信息的坐标。

**扩展：拾取 (Picking)**

与投影变换和视口变换相反的一种变换是：拾取(Picking)。也就是根据屏幕坐标反算出对应的3D对象。我们需要做逆于投影视口变换的操作，将屏幕坐标变换到3D坐标。拾取变换的过程如下所示：

- 通过视口变换矩阵逆矩阵将屏幕坐标变换到NDC坐标
- 然后通过乘以W分量(投射除法的逆变换)将NDC坐标变换到裁剪坐标 
- 通过投影矩阵逆矩阵将裁剪坐标变换到观察坐标 
- 求出经过原点O以及点的拾取射线 
- 拾取射线位于观察空间，通过将拾取射线变换到局部空间进行相交行检测 (这里将拾取变换到局部空间是为了减少运算量，将物体的每个图元变换到世界坐标效率较低)。

### 光栅化阶段

现代的光栅化算法是一个分层的结构，先用一个粗粒度的光栅化器把屏幕空间分为8*8的tile（有的地方是4*4，反正是一个正方形的像素块），判断哪些tile覆盖了三角形。再用精细的光栅化器对tile内的三角形进行逐像素的光栅化（算法巧妙，参考[渲染管线中的不可控、可配置与可控](https://zhuanlan.zhihu.com/p/87508234)）。这种分成两层的光栅化器可以大大提高光栅化过程的效率。

#### 三角形设置 （Triangle Setup）

三角形设置阶段的主要作用是计算出一些在三角形遍历阶段会被多次用到的常量以减少运算量，例如三角形三条边的方程、深度等。

#### 三角形遍历（Triangle Traversal）

三角形遍历为每个被覆盖的像素生成一个片段，并完成了该片段的属性插值。这些片段随后被送入片段着色器等后续阶段。它的核心任务是：

1. **覆盖率测试**：针对每个潜在的像素，判断其中心采样点（或其他指定的采样点）是否位于三角形内部。只有通过测试的像素，管线才会为其生成一个片段。

2. **属性插值**：对于每个需要生成片元的像素，根据三角形三个顶点的属性值（如颜色、纹理坐标、法线等），为这个像素位置插值计算出一个对应的片段属性集。

3. **执行透视校正插值**：这是该阶段至关重要的一个步骤。由于透视投影会造成深度上的非线性变化，简单的线性插值会导致纹理等属性在表面上扭曲。因此，必须使用透视校正插值公式，才能确保在三维空间中均匀的属性，在经过透视投影后，在二维屏幕上也能被正确插值。

   > **透视插值计算**
   >
   > [图形学 - 关于透视矫正插值那些事](https://zhuanlan.zhihu.com/p/403259571)
   >
   > 屏幕坐标属性（例如纹理$u_{i},v_{i}$）、片段重心坐标（$\alpha, \beta, \gamma$）、透视矫正因子（$\frac{1}{z_i}$），其中$i$指片段所属的三个顶点的编号$1,2,3$，对于片段$p$：
   > $$
   > \begin{align}
   > u_p = \frac{\displaystyle \alpha \frac{u_1}{z_1} + \beta \frac{u_2}{z_2} + \gamma \frac{u_3}{z_3}}
   >           {\displaystyle \alpha \frac{1}{z_1} + \beta \frac{1}{z_2} + \gamma \frac{1}{z_3}} \\
   >           
   > v_p = \frac{\displaystyle \alpha \frac{v_1}{z_1} + \beta \frac{v_2}{z_2} + \gamma \frac{v_3}{z_3}}
   >           {\displaystyle \alpha \frac{1}{z_1} + \beta \frac{1}{z_2} + \gamma \frac{1}{z_3}}          
   >          
   > \end{align}
   > $$
   >
   > - 分子是对$u_i*\frac{1}{z_i},v_i*\frac{1}{z_i}$的线性插值
   >
   > - 分母是对对$\frac{1}{z_i}$的线性插值
   >
   > 

### 像素处理阶段

#### 片段着色器（Fragment Shader）

#### 测试合并

**先后顺序：**裁剪测试 -> Alpha测试 -> 模板测试 ->深度测试

##### 深度测试

图形管线会对每一个位置的像素存储一个深度值，称为深度缓冲，代表了该像素点在3D世界中离相机最近物体的深度值。在计算一个物体的像素值时，都会将它的深度值与深度缓冲中的深度值比较，小于则更新深度缓冲和颜色缓冲中的值；否则丢弃。**简单来说，就是根据物体的深度决定是否渲染。**

> **Early-Z 技术**
>
> Early-Z是GPU硬件提供的一项关键优化，它在片段着色器执行前，利用深度缓冲区对光栅化后的片段进行提前深度测试。如果一个片段被确认为完全遮挡，便会被立即丢弃，从而避免后续所有昂贵的着色计算。这项技术能显著提升渲染效率，但其生效有一个严格前提：片段着色器不能修改深度值，也不能执行片段丢弃操作（如discard或clip）。因此，任何使用透明度测试的材质都会导致Early-Z失效，这正是透明物体渲染性能较低的核心原因之一。
>
> **Pre-Z 技术**
>
> Pre-Z是一种主动的渲染优化策略，旨在解决透明度测试导致的Early-Z失效问题。其核心思想是将渲染拆分为两个通道：首先，一个专门的“深度预渲染通道”会关闭颜色写入，仅将所有不透明物体及透明度测试物体的不透明部分的深度信息写入深度缓冲区；随后，在主颜色渲染通道中，基于这个已构建好的高质量深度缓冲区进行渲染。这样，虽然深度预渲染通道本身可能无法享受Early-Z优化，但它为后续的主渲染通道创造了近乎完美的Early-Z生效条件，使得绝大多数不透明片段能在着色前被高效剔除，从而在整体上获得显著的性能提升。

##### Alpha测试

可选的Alpha测试可在深度测试执行前在传入片段上运行。片段的Alpha值与参考值作某些特定的测试（如等于，大于等），如果片段未能通过测试，它将不再进行进一步的处理。Alpha测试经常用于不影响深度缓存的全透明片段的处理。**简单来说，就是根据物体的透明度来决定是否渲染。**

##### 模板测试

模板测试通过模板缓冲来控制像素渲染。模板缓冲记录特定图元的位置，如同在屏幕上设定了一个区域“模板”。渲染时，将片段的参考值与模板值进行比较：满足条件则通过测试并更新像素，否则丢弃该片段。**简单来说，就是根据物体的位置范围决定是否渲染。**

## 光照模型

### Lambert模型

### Phong模型

[LearnOpenGL 基础光照](https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/)

Phong光照模型其实是经验模型，参数信息是通过经验得到的。Phong模型将物体光照分为三个部分进⾏计算，分别是：漫反射、镜面⾼光和环境光。

- **环境光分量**：环境光照用于模拟全局光照效果，其实现方式是为物体表面的所有片段叠加一个较小的光照常量。这一常量代表了场景中其他物体所反射的间接光照，使得即使在没有直接光源照射的区域，也能呈现出基础的亮度和色彩。

  - 具体实现：设置⼀个ambient分量，乘上光照颜⾊和物体颜⾊。

    ````c++
    vec3 ambient = ambientStrength * lightColor * objectColor;
    ````

- **漫反射分量**：漫反射光照的效果取决于光线方向与物体表面法线的夹角：当入射光线与表面法线方向越接近时，该表面片段接收到的光照亮度就越高。

  - 具体实现：计算入射光线向量与表面法线向量的点积，再乘以光的颜色与物体表面颜色。

    ```cpp
    vec3 diffuse = max(dot(norm, lightDir), 0.0) * lightColor * objectColor;
    ```

- **镜面分量**：镜面光照用于模拟光泽物体表面出现的高光亮点。其颜色主要受光源颜色影响，而非物体本身的颜色。在计算中，

  - 具体实现：通过计算视线方向与反射光线方向的点积，结合**反光度（Shininess）**指数参数进行幂运算（`pow`）。反光度值越高，高光区域就越集中、越尖锐。最终将该计算结果乘以整体光照强度系数与物体颜色，得到镜面高光分量。

    ```c++
    vec3 reflectDir = reflect(-lightDir, norm);
    vec3 specular = specularStrength * pow(max(dot(viewDir, reflectDir), 0.0), 32) * objectColor;
    ```

### Blinn-Phong模型

[LearnOpenGL 高级光照](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/01%20Advanced%20Lighting/)

**Blinn-Phong光照模型是对Phong⽒光照模型的改进，Phong模型在处理⾼光时会出现光照不连续的情况。**

原因：Phong模型在物体反光度较低时，会产生大片高光区域，且高光边缘容易出现明显的明暗断层。这是因为其计算依赖观察向量与反射向量的点积，而该夹角不得超过90度；一旦点积结果为负值，镜面光分量会直接被截断为0。尽管这种截断对镜面反射是合理的（背向视线方向的光不应产生镜面高光），但在处理漫反射光照时，这种突变会带来不自然的光照过渡。为此，Blinn-Phong模型进行了改进：它引入**半程向量（Halfway vector）**代替反射向量，将观察向量与光线向量的中点与法线进行比较，从而使高光过渡更平滑，有效避免了Phong模型在低反光度下的视觉瑕疵，同时计算效率也更高。

```c++
vec3 lightDir = normalize(lightPos - FragPos);
vec3 viewDir = normalize(viewPos - FragPos);
ve3 halfwayDir = normalize(lightDir + viewDir);
vec3 specular = specularStrength * pow(max(dot(normal, halfwayDir), 0.0), shininess) * objectColor;
```

Blinn-Phong模型虽然需要额外计算半程向量，但避免了Phong模型中计算反射光方向的开销，在多数情况下总体性能更优，且能提供更平滑的高光效果。

### PBR

[LearnOpenGL PBR](https://learnopengl-cn.github.io/07%20PBR/01%20Theory/)

PBR（Physically Based Rendering，基于物理的渲染）是一系列严格遵循真实世界光学物理规律的渲染技术的统称。它通过更科学地建模光线与材质表面的能量交互（如反射、折射、吸收等），能够模拟从金属到非金属、粗糙到光滑等各类材质在不同光照条件下的真实表现，渲染出的视觉效果相比Phong或Blinn-Phong等经验模型具有更高的一致性、可信度与艺术可控性。

判断一种PBR光照模型是否是属于基于物理的：

1. 基于微平面的表面模型
2. 能量守恒
3. 应用基于物理的BRDF

#### 微平面模型

PBR 的理论核心是**微平面理论**。该模型将物体宏观表面视为由无数微观尺度的镜面所构成。表面的视觉粗糙度本质上由这些微平面的排列秩序决定：排列越混乱，表面越粗糙；排列越一致，表面则越光滑。这一微观结构直接支配了镜面反射的形态——粗糙表面将入射光向多个方向散射，形成模糊、扩散的高光；而光滑表面则将光线集中反射，产生锐利、清晰的耀斑。

由于微平面远小于像素尺度，我们通过一个介于 0 到 1 之间的**粗糙度**参数对其进行统计性描述。在计算中，**半程向量**被用来衡量微平面取向与理想反射方向的匹配程度：微平面的法线方向越接近半程向量，其对镜面反射的贡献就越强。因此，当粗糙度为 0 时，微平面排列完全一致，产生极其微小而锐利的高光点；当粗糙度为 1 时，微平面方向高度离散，导致反射光斑宽泛而模糊。

PBR 中通常用于描述微平面法线分布的 **Trowbridge-Reitz GGX** 模型为：
$$
D(\mathbf{h}) = \frac{\alpha^2}{\pi \bigl[ (\mathbf{n} \cdot \mathbf{h})^2 (\alpha^2 - 1) + 1 \bigr]^2}
$$

```c++
float a2 = a*a;
float NdotH = max(dot(N, H), 0.0);
float NdotH2 = NdotH*NdotH;
float denom = (NdotH2 * (a2 - 1.0) + 1.0);
denom = PI * denom * denom;
D = a2 / denom;
```



![img](D:\Documents\notes\images\ndf.png)如果我们把h当成是不同粗糙度参数下，平面法向量和光线方向向量之间的中间向量的话，我们可以得到如上图示的效果：当粗糙度很低（也就是说表面很光滑)的时候，与半程向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与h向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。

#### 能量守恒

微平面模型严格遵循**能量守恒**原则：对于非自发光的表面，其反射与折射出的总能量不得超过入射光能量。

为此，模型必须明确区分两种不同的光能传递路径：

1. **镜面反射**：光线在表面直接反射的部分，构成镜面高光。
2. **漫反射**：光线折射进入表面，经内部散射后部分再射出（或被吸收）的部分，构成漫反射颜色。

这一区分确保了能量分配的物理正确性：光线在碰撞点即被分流，镜面反射与漫反射能量之和严格不超过原始入射能量，从而在渲染中杜绝了“过度增亮”的非物理现象。

**PBR 模型中的简化**
标准的实时 PBR 模型对此过程进行了关键简化：它假设折射光在**进入表面的那一点即被完全吸收并就地重新射出**，不再模拟其在内部的多重散射与传播路径。这一简化极大地提升了计算效率。

**次表面散射**
对于皮肤、蜡、大理石等材质，上述简化会丢失关键的视觉特征（如透光感、柔和色泽过渡）。因此**次表面散射**技术被引入，它显式地模拟了光线在材质内部的散射过程，显著提升了此类材质的视觉真实感，但代价是更高的计算开销。

在物理材质表示中，**漫反射分量主要描述材质的固有色**（即吸收与再辐射特性），而**镜面反射分量则描述光线在表面直接弹射的属性**（如光泽度与反射强度）。

在 PBR 渲染中，**金属** 与 **非金属**（电介质）的材质特性有根本区别：

- **非金属（如塑料、木材）**：光线部分反射（高光），部分折射进入材质并散射，形成**漫反射颜色**。
- **金属（如金、铜）**：折射光被内部自由电子迅速吸收，因此**没有漫反射**，其表面颜色完全来自**镜面反射光**。

因此，PBR 管线使用 **“金属度”** 参数来区分处理这两种材质：

- **金属度 = 1**：仅计算镜面反射，且反射光可带有颜色（如金色）。
- **金属度 = 0**：分别计算漫反射（固有色）和无色的镜面高光。

#### BRDF

BRDF，或者说双向反射分布函数，它接受入射（光）方向$w_i$，出射（观察）方向$w_o$，平面法线$n$以及一个用来表示微平面粗糙程度的参数$\alpha$作为函数的输入参数。BRDF可以近似的求出每束光线对一个给定了材质属性的平面上最终反射出来的光线所作出的贡献程度。简言之，**它量化了来自某一方向的光线，有多少比例最终反射到了观察者的眼中**。

Blinn-Phong模型被认为是一个光照模型，但是它并没有遵循能量守恒定律，因此不被认为是基于物理的渲染。现在已经有很好几种BRDF都能近似的得出物体表面对于光的反应，但是几乎所有实时渲染管线使用的都是一种被称为Cook-Torrance BRDF模型。

##### Cook-Torance BRDF

Cook-Torrance BRDF 模型包含漫反射与镜面反射两部分：

漫反射项（Lambertian）的归一化表达式为：
$$
\begin{aligned}
f_r = k_d f_{\text{Lambert}} + k_s f_{\text{Cook-Torrance}}
\end{aligned}
$$
这里的$k_d$是早先提到过的入射光线中**被折射**部分的能量所占的比率，而$k_s$是**被反射**部分的比率。Cook-Torrance BRDF的漫反射部分通常采用Lambertian模型表示，其公式为：
$$
\begin{aligned}
f_{\text{lambert}} = \frac{c}{\pi}
\end{aligned}
$$
$c$表示表面颜色，通常是Albedo（漫反射贴图） 。除$\pi$是为了对漫反射光进行标准化，因为前面含有BRDF的积分方程是$\pi$影响。

Cook-Torrance BRDF 的右侧表示镜面反射部分，用如下公式表示：
$$
\begin{aligned}
f_{\text{Cook-Torrance}}= \frac{DFG}{4 (\omega_o \cdot \mathbf{n})(\omega_i \cdot \mathbf{n})}
\end{aligned}
$$
字母D，F与G分别代表着一种类型的函数，各个函数分别用来近似的计算出表面反射特性的一个特定部分。三个函数分别为法线分布函数(Normal **D**istribution Function)，菲涅尔方程(**F**resnel Rquation)和几何函数(**G**eometry Function)：

- **法线分布函数**：估算在受到表面粗糙度的影响下，朝向方向与半程向量一致的微平面的数量。这是用来估算微平面的主要函数。
- **菲涅尔方程**：菲涅尔方程描述了光线在表面反射与折射的能量比率，该比率会随观察角度的变化而改变。当光线击中表面时，菲涅尔方程可根据当前视角计算出反射光所占的百分比，剩余能量即为折射部分，从而满足能量守恒。（**Blinn-Phong等模型不遵守菲涅尔定律，因此会出现叠加过亮。**）
- **几何函数**：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。

最终的Cook-Torance反射率方程，完整描述了点$p$处沿观察方向$w_o$的出射辐射率$L_o$是如何由所有可能的入射光贡献累加而成的。
$$
\begin{aligned}
L_o(p, \omega_o) = \int_{\Omega} 
\left(
k_d \frac{c}{\pi} 
+ k_s \frac{DFG}{4 (\omega_o \cdot \mathbf{n})(\omega_i \cdot \mathbf{n})}
\right)
L_i(p, \omega_i) (\mathbf{n} \cdot \omega_i) \, d\omega_i
\end{aligned}
$$

#### PBR材质

**反照率 (Albedo)**：表示表面的基础颜色或反射率，不含光照与阴影信息，仅为材质本身的颜色。

**法线 (Normal)**：与传统的法线贴图相同，用于模拟表面的凹凸细节。

**金属度 (Metallic)**：它决定了基础色（反照率）在光照计算中的用途。对于金属材质（金属度=1），光线几乎被完全吸收，因此漫反射部分接近黑色，而镜面反射会直接反射出基色本身的颜色（**镜面反射使用albedo**）。对于非金属材质（金属度=0），光线会部分散射形成固有色，其漫反射部分显示基础色（**漫反射使用albedo**），而镜面反射通常呈现为无色的高光。

**粗糙度 (Roughness)**：定义表面的光滑程度，数值越高表面越粗糙，镜面高光越模糊扩散。

**环境光遮蔽 (AO)**：提供预计算的遮挡阴影，用于增强缝隙、凹陷处的立体感，通常在光照计算后期叠加使用。比如如果我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而AO贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。

## 纹理贴图

### MipMap

### 法向贴图

## 全局光照

### 光线追踪

#### 路径追踪

#### 递归式光线追踪

#### 双向路径追踪

#### Metropolis

#### 光子映射

### AO

AO（Ambient Occlusion）环境光遮蔽是一种模拟全局光照中遮蔽阴影的技术。它通过计算物体表面因周围几何体遮挡而减少的环境光，来生成重要的视觉明暗效果。该技术能有效描绘物体交界处、裂缝、孔洞等细节区域的柔和阴影，从而解决漏光、阴影漂浮等问题，显著增强场景的深度感、立体感和细节表现力。

从直观的视觉效果看，开启环境光遮蔽后，场景的整体亮度会趋于自然，而局部细节——尤其是暗部阴影——会变得更加清晰和丰富，画面因此显得更加扎实、富有层次。

#### SSAO

SSAO（Screen Space Ambient Occlusion）屏幕空间环境光遮蔽是一种用于实时实现近似环境光遮蔽效果的渲染技术。通过获取像素的深度缓冲、法线缓冲来计算实现，来近似的表现物体在间接光下产生的阴影。

### 基于预计算的全局光照

#### IBL

#### PRT

## 延迟渲染

## 阴影

## 抗拒齿